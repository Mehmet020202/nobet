import{j as m,b as D}from"./radix-ui-DGgDhZMf.js";import{a as S}from"./index-3ZT1LmJ7.js";function T({className:a,...l}){return m.jsx("div",{"data-slot":"card",className:S("bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",a),...l})}function V({className:a,...l}){return m.jsx("div",{"data-slot":"card-header",className:S("@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",a),...l})}function F({className:a,...l}){return m.jsx("div",{"data-slot":"card-title",className:S("leading-none font-semibold",a),...l})}function G({className:a,...l}){return m.jsx("div",{"data-slot":"card-description",className:S("text-muted-foreground text-sm",a),...l})}function J({className:a,...l}){return m.jsx("div",{"data-slot":"card-content",className:S("px-6",a),...l})}const b="NobetSistemiDB",w=1,L=()=>{const[a,l]=D.useState(null);D.useEffect(()=>{d()},[]);const d=()=>new Promise((s,o)=>{const t=indexedDB.open(b,w);t.onerror=()=>{console.error("IndexedDB error:",t.error),o(t.error)},t.onsuccess=()=>{const c=t.result;l(c),s(c)},t.onupgradeneeded=c=>{const e=c.target.result;if(!e.objectStoreNames.contains("doctors")){const n=e.createObjectStore("doctors",{keyPath:"id"});n.createIndex("name","name",{unique:!1}),n.createIndex("specialty","specialty",{unique:!1})}if(!e.objectStoreNames.contains("duties")){const n=e.createObjectStore("duties",{keyPath:"id"});n.createIndex("date","date",{unique:!1}),n.createIndex("doctor_id","doctor_id",{unique:!1}),n.createIndex("shift_type","shift_type",{unique:!1}),n.createIndex("year_month","year_month",{unique:!1})}if(e.objectStoreNames.contains("settings")||e.createObjectStore("settings",{keyPath:"id"}),!e.objectStoreNames.contains("red_days")){const n=e.createObjectStore("red_days",{keyPath:"id"});n.createIndex("doctor_id","doctor_id",{unique:!1}),n.createIndex("date","date",{unique:!1})}if(!e.objectStoreNames.contains("blue_days")){const n=e.createObjectStore("blue_days",{keyPath:"id"});n.createIndex("doctor_id","doctor_id",{unique:!1}),n.createIndex("date","date",{unique:!1})}if(!e.objectStoreNames.contains("special_assignments")){const n=e.createObjectStore("special_assignments",{keyPath:"id"});n.createIndex("doctor_id","doctor_id",{unique:!1}),n.createIndex("date","date",{unique:!1})}l(e)}});return{addDoctor:async s=>{let o=a;return o||(o=await d()),new Promise((t,c)=>{const r=o.transaction(["doctors"],"readwrite").objectStore("doctors").add(s);r.onsuccess=()=>t(r.result),r.onerror=()=>c(r.error)})},getDoctors:async()=>{let s=a;return s||(s=await d()),new Promise((o,t)=>{if(!s){t(new Error("Database not initialized"));return}const n=s.transaction(["doctors"],"readonly").objectStore("doctors").getAll();n.onsuccess=()=>o(n.result),n.onerror=()=>t(n.error)})},updateDoctor:async s=>{let o=a;return o||(o=await d()),new Promise((t,c)=>{const r=o.transaction(["doctors"],"readwrite").objectStore("doctors").put(s);r.onsuccess=()=>t(r.result),r.onerror=()=>c(r.error)})},deleteDoctor:async s=>{let o=a;return o||(o=await d()),new Promise((t,c)=>{const e=o.transaction(["doctors","duties","red_days","special_assignments"],"readwrite");e.objectStore("doctors").delete(s);const y=e.objectStore("duties").index("doctor_id").openCursor(IDBKeyRange.only(s));y.onsuccess=f=>{const g=f.target.result;g&&(g.delete(),g.continue())};const p=e.objectStore("red_days").index("doctor_id").openCursor(IDBKeyRange.only(s));p.onsuccess=f=>{const g=f.target.result;g&&(g.delete(),g.continue())};const x=e.objectStore("special_assignments").index("doctor_id").openCursor(IDBKeyRange.only(s));x.onsuccess=f=>{const g=f.target.result;g&&(g.delete(),g.continue())},e.oncomplete=()=>t(),e.onerror=()=>c(e.error)})},saveDuties:async s=>(a||await d(),new Promise((o,t)=>{const c=a.transaction(["duties"],"readwrite"),e=c.objectStore("duties");if(s.length>0){const r=s[0].year_month,y=e.index("year_month").openCursor(IDBKeyRange.only(r));y.onsuccess=u=>{const _=u.target.result;_?(_.delete(),_.continue()):s.forEach(p=>{e.add({...p,id:crypto.randomUUID()})})}}c.oncomplete=()=>o(),c.onerror=()=>t(c.error)})),getDuties:async(s,o)=>{let t=a;return t||(t=await d()),new Promise((c,e)=>{if(!t){e(new Error("Database not initialized"));return}const i=t.transaction(["duties"],"readonly").objectStore("duties").index("year_month"),y=`${s}-${String(o).padStart(2,"0")}`,u=i.getAll(IDBKeyRange.only(y));u.onsuccess=()=>c(u.result),u.onerror=()=>e(u.error)})},addRedDay:async(s,o)=>(a||await d(),new Promise((t,c)=>{const r=a.transaction(["red_days"],"readwrite").objectStore("red_days").add({id:crypto.randomUUID(),doctor_id:s,date:o,created_at:new Date().toISOString()});r.onsuccess=()=>t(r.result),r.onerror=()=>c(r.error)})),getRedDays:async s=>(a||await d(),new Promise((o,t)=>{const r=a.transaction(["red_days"],"readonly").objectStore("red_days").index("doctor_id").getAll(IDBKeyRange.only(s));r.onsuccess=()=>o(r.result.map(i=>i.date)),r.onerror=()=>t(r.error)})),deleteRedDay:async(s,o)=>(a||await d(),new Promise((t,c)=>{const i=a.transaction(["red_days"],"readwrite").objectStore("red_days").index("doctor_id").openCursor(IDBKeyRange.only(s));i.onsuccess=y=>{const u=y.target.result;u?u.value.date===o?(u.delete(),t()):u.continue():t()},i.onerror=()=>c(i.error)})),addBlueDay:async(s,o)=>(a||await d(),new Promise((t,c)=>{const r=a.transaction(["blue_days"],"readwrite").objectStore("blue_days").add({id:crypto.randomUUID(),doctor_id:s,date:o,created_at:new Date().toISOString()});r.onsuccess=()=>t(r.result),r.onerror=()=>c(r.error)})),getBlueDays:async s=>(a||await d(),new Promise((o,t)=>{const r=a.transaction(["blue_days"],"readonly").objectStore("blue_days").index("doctor_id").getAll(IDBKeyRange.only(s));r.onsuccess=()=>o(r.result.map(i=>i.date)),r.onerror=()=>t(r.error)})),deleteBlueDay:async(s,o)=>(a||await d(),new Promise((t,c)=>{const i=a.transaction(["blue_days"],"readwrite").objectStore("blue_days").index("doctor_id").openCursor(IDBKeyRange.only(s));i.onsuccess=y=>{const u=y.target.result;u?u.value.date===o?(u.delete(),t()):u.continue():t()},i.onerror=()=>c(i.error)})),addSpecialAssignment:async(s,o,t)=>(a||await d(),new Promise((c,e)=>{const i=a.transaction(["special_assignments"],"readwrite").objectStore("special_assignments").add({id:crypto.randomUUID(),doctor_id:s,date:o,shift_type:t,created_at:new Date().toISOString()});i.onsuccess=()=>c(i.result),i.onerror=()=>e(i.error)})),getSpecialAssignments:async s=>(a||await d(),new Promise((o,t)=>{const r=a.transaction(["special_assignments"],"readonly").objectStore("special_assignments").index("doctor_id").getAll(IDBKeyRange.only(s));r.onsuccess=()=>{const i={};r.result.forEach(y=>{i[y.date]=y.shift_type}),o(i)},r.onerror=()=>t(r.error)})),saveSettings:async s=>(a||await d(),new Promise((o,t)=>{const n=a.transaction(["settings"],"readwrite").objectStore("settings").put({id:"app_settings",...s,updated_at:new Date().toISOString()});n.onsuccess=()=>o(n.result),n.onerror=()=>t(n.error)})),getSettings:async()=>(a||await d(),new Promise((s,o)=>{const e=a.transaction(["settings"],"readonly").objectStore("settings").get("app_settings");e.onsuccess=()=>s(e.result),e.onerror=()=>o(e.error)}))}};export{T as C,V as a,F as b,G as c,J as d,L as u};
